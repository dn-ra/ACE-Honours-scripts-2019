'''This from RepeatM Clusterer module - author wwood.
To be used here for testing of single_contig clustering from delta match files'''



#pattern to determine if contig name is in spades format
import re
from logging import warning
spadespattern = re.compile(r'NODE_[0-9]*_', re.UNICODE)

class Contig_Cluster(object):
    def __init__(self, node_list):
        self.nodes = node_list
        self.size = len(self.nodes)
        
        if self.has_spades() == True:
            length_total = 0
            cov_total = 0
            spades_seqs = 0
            for node in self.nodes:
                if spadespattern.match(node):
                    nodeinfo = node.split('_')
                    length_total += int(nodeinfo[-3])
                    cov_total += float(nodeinfo[-1])
                    spades_seqs +=1
                else:
                    warning('Some contigs in this cluster were not generated by Spades. Non-Spades contig names not supported yet')
            self.av_cov = cov_total / spades_seqs
            self.av_length = length_total / spades_seqs
        else:
            warning('Non-Spades contig names not supported yet')
        
        
    
    def has_spades(self):
        spades = False
        for c in self.nodes:
            if spadespattern.match(c):
                spades = True
                break
        return spades
    
    def plas_label(self):
        return None
    
    
    def get_seqs(self):
        
        return(seqlist)
    #def get_seqs:

    def label_cluster():
    '''label cluster as linear or circular based on alignment evidence
    Evidence includes: 
    - Does the sequence consistenly start and end with the same ORF? (don't need to know the proteins: Use OrfM)
    - Do regions align globally or differentially?
    - do endings overlap?
    '''
    #OrfM is already a subprocess in clusterer module
    

    def sort_clusters(cluster_list):
    '''sort clusters by: 
    1. N in cluster, 2. length of N, 3. coverage of N
    Don't get it just from the names. That's SPAdes format but some people won't use spades
    Get it from the data directly. But megahit doesn't include any of this informaiton in the contig name, 
    and coverage would need reads mapped'''
             
        
        
        def sortclustersbysize(c):
            return len(c)
        
        def sortclusterbylength(c):
            if c.has_spades() == False:
                warning('Non-spades contig names not supported yet')
            ##flag to  do this if contig format is spades
            for cluster in cluster_list:
                
            ##flag to do this if contig format is spades


'''!!! Don't edit this. This is what will be in the clusterer module of repeatm!!!'''
def single_linkage_cluster(links): #originally a class function. changed here to just be 'links' as input for testing. Refer to original RepeatM module for original inputs.
    '''Not sure this is the fastest, but eh. Return a list of lists, where each
    list is a cluster.'''
    clusters = {}
    next_group_number = 1 # counter of cluster numbers. goes up by one as each new cluster grouping is created
    for link in links: #for each link generated by mash and such
        one = link[0]
        two = link[1] #first and second elements of the match
        if one in clusters and two in clusters: #see if both of these are already clustered somewehre. bring those clusters together
            old_one_number = clusters[one] # ._._. set 'old_one' as cluster[one], set cluster[one] as cluster[two]
            clusters[one] = clusters[two] #now both one and two have same cluster, old cluster of one is stored in tmp variable
            names_to_fix = [] #??
            for name, number in clusters.items():
                if number == old_one_number: 
                    names_to_fix.append(name) #get all names that are already in that old cluster and append them to a list
            for n in names_to_fix:
                clusters[n] = clusters[two] #set cluster number for all the names_to_fix sequences to be the same as clusters[two] (which is now also the same as clusters[one]
        elif one in clusters:
            clusters[two] = clusters[one] # of one already clustered, cluster 2 with it
        elif two in clusters:
            clusters[one] = clusters[two] # if two already clustered, cluster 1 with it
        else:
            clusters[one] = next_group_number
            clusters[two] = next_group_number
            next_group_number += 1 # if not clustered, set both in new cluster, increase cluster counter by one for next new cluster
    reverse = {} #dictionary of reversed name: cluster dict
    for name, number in clusters.items():
        if number not in reverse:
            reverse[number] = [] #add that cluster number into dict if not there yet
        reverse[number].append(name) #add id into that cluster dict
    return list(reverse.values()) #output as list of lists I GET IT!
    